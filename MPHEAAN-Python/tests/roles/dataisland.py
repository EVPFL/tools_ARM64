'''DataIsland of federated learing.'''
from HEAAN import ZZ, Uint64_t, ComplexDouble, SecretKey, Key, Plaintext, Ciphertext, Ciphertexts, SKShares
from MKLHS import LHSSKey, LHSPKey
from LHH import LHHVal, LHHMsgs, LHHHash

from mkTPFL.ckks.ckks_parameters import *
from mkTPFL.ckks.ckks_encoder import CKKSMessage, CKKSEncoder
from mkTPFL.ckks.ckks_key_generator import CKKSKeyGenerator
from mkTPFL.ckks.ckks_encryptor import CKKSEncryptor
from mkTPFL.ckks.ckks_decryptor import CKKSDecryptor

from mkTPFL.mklhs.mklhs_parameters import *
from mkTPFL.mklhs.mklhs_encoder import MKLHSEncoder, modelCiph2LHSMsg
from mkTPFL.mklhs.mklhs_verifier import MKLHSVerifier

from mkTPFL.utils.lhh_parameters import LHH_init
from mkTPFL.utils.class_transformer import getData, DataLHSSKey, DataLHSPKey, DataSecretKey, DataKey, DataZZ, data2Obj,getModelSolnHash

from math import ceil, floor
import numpy
import random
import sys

import time
from memory_profiler import profile
import gc



class DataIsland:
    ''' Privacy-preserving Federated Learning Data Island: 
        An role who holds the local model.

    Attributes:
        di_index: index of this data island. 
        
        # number & threshold of roles
        sv_num: number of all servers (SVs). 
        sv_threshold: minimum number of SVs needed to recover secretsã€‚
            (this simple version only supports single server case. i.e., sv_num = sv_threshold = 1.)
        di_num: number of all data islands (DIs).
        di_threshold: minimum number of DIs needed to recover the secret. 
            (i.e., the number of attended DIs in one aggregation must over di_threshold.)
        
        # about CKKS encryption
        ckks_params: public parameter of CKKS scheme.
        (secret_key, public_key): CKKS key pair for encrypting iterkey.
        secret_key_shares: shamir shares of this DIs' secret_key.
            (shares are distributed to other DIs. i.e., threshold = di_threshold, quantity = di_num.)
        (enc_secret_key, enc_public_key, enc_relin_key, enc_rot_keys): 
            (public_key, relin_key, rot_keys) corresponding to this DI's enc_secret_key,
            which are used to encrypt and evaluation the local model.
        di_public_keys: 
            public_keys corresponding to all DIs' secret_keys.
            (i.e., the validation SV used it to evaluation the DIs' local model ciphertexts)
        aggregation_public_key: 
            the public key generated by aggregating attended DIs' public_keys in one iteration. 
            (i.e., each attened DI used it to encrypt its iter_key in one iteration.)
        validation_dataset: some samples are selected randomly from original trainning dataset.
        validation_ciph_dataset:
            the validation_ciph_dataset is the ciphertext of its validation_dataset.
            (i.e., this DI uses its enc_public_key to encrypt each sample of its validation_dataset.)
        
        # about MKLHS signuature
        mklhs_params: public parameter of MKLHS scheme.
        (sign_secret_key, sign_public_key):
            sign_public_key corresponding to this DI's sign_secret_key.
        di_sign_public_keys:
            public_keys corresponding to all DIs' sign_secret_keys.

        # # about model
        # model_name: model name.
        #     (this simple version only supports 'logistic' model. i.e., model_name = 'logistic'.)

    Methods:
        # KEY GENARATION METHODS
        # ENCRYPTION METHODS        
        # DECRYPTION METHODS
        # PART DECRYPTION METHODS
        # CIPHERTEXTS AGGREGATION METHODS
        # SHARES RECOVER METHODS
        # GET GLOBAL MODEL METHODS
        # EVALUATION MODEL METHODS
        # VERIFY SIGNATURE METHODS
        # EVALUATION SIGNATURE METHODS
        
    '''

    def __init__(self, di_index, di_num=None, sv_num=None, di_threshold=None, sv_threshold=None,
                    ckks_params=None, 
                    secret_key=None, public_key=None, secret_key_shares=None, 
                    enc_secret_key=None, enc_public_key=None, enc_relin_key=None, enc_rot_keys=None,
                    di_public_keys=None, aggregation_public_key=None,
                    mklhs_params=None, sign_secret_key=None, sign_public_key=None, di_sign_public_keys=None, 
                    validation_dataset=None, validation_ciph_dataset=None):
        '''Initializes DataIsland.

        Args:
            ckks_params (Parameters):Parameters of ckks scheme.
            secret_key (SecretKey): Secret key used for decryption.
        '''
        self.di_index = di_index
        self.di_num = di_num
        self.sv_num = sv_num
        self.di_threshold = di_threshold if di_threshold else self.di_num
        self.sv_threshold = sv_threshold if sv_threshold else self.sv_num
        
        self.ckks_params = ckks_params
        self.__secret_key = secret_key
        self.__secret_key_shares = secret_key_shares # shares of sk for multiple SVs or DIs
        self.__public_key = public_key
        self.__di_public_keys = di_public_keys
        self.__di_secret_key_shares = None # shares of all dis' sk
        self.__agg_sk_share = None

        self.__enc_secret_key = enc_secret_key # for the case: only one server
        self.__enc_public_key = enc_public_key # for the case: only one server
        self.__enc_relin_key = enc_relin_key  # for the case: only one server
        self.__enc_rot_keys = enc_rot_keys  # for the case: only one server

        self.mklhs_params = mklhs_params
        self.__sign_secret_key = sign_secret_key
        self.__sign_public_key = sign_public_key
        self.__di_sign_public_keys = di_sign_public_keys
        

        # keys from file
        self.enc_secret_key_file = None
        self.enc_public_key_file = None
        self.enc_relin_key_file = None
        self.enc_rot_keys_file = None 
        self.secret_key_file = None
        self.secret_key_shares_file = None
        self.public_key_file = None
        self.di_public_keys_file = None
        self.di_secret_key_shares_file = None
        self.di_secret_key_shares_dir = None
        self.sign_secret_key_file = None
        self.sign_public_key_file = None
        self.di_sign_public_keys_file = None

        # self.model_name = model_name
        self.validation_dataset = validation_dataset
        self.validation_ciph_dataset = validation_ciph_dataset

        # each iteration
        self.aggregation_public_key = aggregation_public_key
        self.enc_rv_iteration = None # for the case: only one server in one iteration


    @property
    def threshold(self):
        if self.sv_num == 1:
            threshold = self.di_threshold if self.di_threshold else self.di_num
        else:
            threshold = self.sv_threshold if self.sv_threshold else self.sv_num
        return threshold

    @property
    def quantity(self):
        if self.sv_num == 1:
            quantity = self.di_num
        else:
            quantity = self.sv_num
        return quantity

    @property
    def secret_key(self):
        if self.__secret_key:
            return self.__secret_key
        elif self.secret_key_file:
            sk_data = getData(file_path=self.secret_key_file)
            return data2Obj(sk_data, 'SecretKey')
        else:
            return None

    @property
    def public_key(self):
        if self.__public_key:
            return self.__public_key
        elif self.public_key_file:
            key_data = getData(file_path=self.public_key_file)
            return data2Obj(key_data, 'Key')
        else:
            return None

    @property
    def sign_secret_key(self):
        if self.__sign_secret_key:
            return self.__sign_secret_key
        elif self.sign_secret_key_file:
            key_data = getData(file_path=self.sign_secret_key_file)
            return data2Obj(key_data, 'LHSSKey')
        else:
            return None

    @property
    def sign_public_key(self):
        if self.__sign_public_key:
            return self.__sign_public_key
        elif self.sign_public_key_file:
            key_data = getData(file_path=self.sign_public_key_file)
            return data2Obj(key_data, 'LHSPKey')
        else:
            return None

    @property
    def enc_secret_key(self):
        if self.__enc_secret_key:
            return self.__enc_secret_key
        elif self.enc_secret_key_file:
            key_data = getData(file_path=self.enc_secret_key_file)
            return data2Obj(key_data, 'SecretKey')
        else:
            return None

    @property
    def enc_public_key(self):
        if self.__enc_public_key:
            return self.__enc_public_key
        elif self.enc_public_key_file:
            key_data = getData(file_path=self.enc_public_key_file)
            return data2Obj(key_data, 'Key')
        else:
            return None

    @property
    def enc_relin_key(self):
        if self.__enc_relin_key:
            return self.__enc_relin_key
        elif self.enc_relin_key_file:
            key_data = getData(file_path=self.enc_relin_key_file)
            return data2Obj(key_data, 'Key')

    @property
    def enc_rot_keys(self):
        if self.__enc_rot_keys:
            return self.__enc_rot_keys
        elif self.enc_rot_keys_file:
            keys_data = getData(file_path=self.enc_rot_keys_file)
            return [ data2Obj(key_data, 'Key') for key_data in keys_data ]
        else:
            return None

    @property
    def secret_key_shares(self):
        if self.__secret_key_shares:
            return self.__secret_key_shares
        elif self.secret_key_shares_file:
            shares_data = getData(file_path=self.secret_key_shares_file)
            if isinstance(shares_data[0], DataSecretKey): # when 1<sv_num<=sv_threshold, sk_shares is sk
                return [ data2Obj(key_data, 'SecretKey') for key_data in shares_data ]
            else:
                return data2Obj(shares_data, 'KeyShares')   
        else:
            return None

    @property
    def di_secret_key_shares(self):
        if self.__di_secret_key_shares:
            return self.__di_secret_key_shares
        elif self.di_secret_key_shares_dir:
            datas = [ getData(file_path=self.di_secret_key_shares_dir+str(i)+'.pkl') for i in range(self.di_num)]
            return [ data2Obj(data, 'KeyShare') for data in datas ]
        elif self.di_secret_key_shares_file:
            if isinstance(self.di_secret_key_shares_file, list):
                datas = [ getData(file_path=f) for f in self.di_secret_key_shares_file ]
                return [ data2Obj(data, 'KeyShare') for data in datas ]
            else:
                shares_data = getData(file_path=self.di_secret_key_shares_file)
                return data2Obj(shares_data, 'KeyShares')
        else:
            return None

    def get_di_secret_key_share(self, i):
        if self.__di_secret_key_shares:
            return self.__di_secret_key_shares[i]
        elif self.di_secret_key_shares_dir:
            data = getData(file_path=self.di_secret_key_shares_dir+str(i)+'.pkl')
            return data2Obj(data, 'KeyShare')
        elif self.di_secret_key_shares_file:
            if isinstance(self.di_secret_key_shares_file, list):
                data = getData(file_path=self.di_secret_key_shares_file[i])
                return data2Obj(data, 'KeyShare')
            else:
                shares_data = getData(file_path=self.di_secret_key_shares_file)
                return data2Obj(shares_data, 'KeyShares')[i]
        else:
            return None

    @property
    def agg_sk_share(self):
        if self.__agg_sk_share:
            return self.__agg_sk_share
        elif self.di_secret_key_shares_dir:
            data = getData(file_path=self.di_secret_key_shares_dir+'agg.pkl')
            return data2Obj(data, 'KeyShare')
        else:
            return None

    def get_agg_sk_share(self):
        di_inxs = [i for i in range(self.di_num)]
        sk_shares_list = self.getSKShares(di_inxs)
        return self.__sharesAggregate__(sk_shares_list)

    @property
    def di_public_keys(self):
        if self.__di_public_keys:
            return self.__di_public_keys
        elif self.di_public_keys_file:
            keys_data = [ getData(file_path=key_file) for key_file in self.di_public_keys_file ]
            return [ data2Obj(key_data, 'Key') for key_data in keys_data ]
        else:
            return None

    def get_di_public_key(self, i):
        if self.__di_public_keys:
            return self.__di_public_keys[i]
        elif self.di_public_keys_file:
            key_data = getData(file_path=self.di_public_keys_file[i])
            return data2Obj(key_data, 'Key')
        else:
            return None

    @property
    def di_sign_public_keys(self):
        if self.__di_sign_public_keys:
            return self.__di_sign_public_keys
        elif self.di_sign_public_keys_file:
            keys_data = [ getData(file_path=key_file) for key_file in self.di_sign_public_keys_file ]
            return [ data2Obj(key_data, 'LHSPKey') for key_data in keys_data ]
        else:
            return None

    def get_di_sign_public_key(self, i):
        if self.__di_sign_public_keys:
            return self.__di_sign_public_keys[i]
        elif self.di_sign_public_keys_file:
            key_data = getData(file_path=self.di_sign_public_keys_file[i])
            return data2Obj(key_data, 'LHSPKey')
        else:
            return None

    def set_di_public_keys(self, di_public_keys_list):
        if isinstance(di_public_keys_list[0], Key):
            self.__di_public_keys = di_public_keys_list
            self.di_public_keys_file = None
        else:
            self.__di_public_keys = None
            self.di_public_keys_file = di_public_keys_list

    def set_di_sign_public_keys(self, di_sign_public_keys_list):
        if isinstance(di_sign_public_keys_list[0], LHSPKey):
            self.__di_sign_public_keys = di_sign_public_keys_list
            self.di_sign_public_keys_file = None
        else:
            self.__di_sign_public_keys = None
            self.di_sign_public_keys_file = di_sign_public_keys_list

        
    def resetKeys2Files(self, keys2Files):
        if 'secret_key' in keys2Files:
            self.__secret_key = None
            self.secret_key_file = keys2Files['secret_key']
        if 'public_key' in keys2Files:
            self.__public_key = None
            self.public_key_file = keys2Files['public_key']
        if 'enc_secret_key' in keys2Files:
            self.__enc_secret_key = None
            self.enc_secret_key_file = keys2Files['enc_secret_key']
        if 'enc_public_key' in keys2Files:
            self.__enc_public_key = None
            self.enc_public_key_file = keys2Files['enc_public_key']
        if 'enc_relin_key' in keys2Files:
            self.__enc_relin_key = None
            self.enc_relin_key_file = keys2Files['enc_relin_key']
        if 'enc_rot_keys' in keys2Files:
            self.__enc_rot_keys = None
            self.enc_rot_keys_file = keys2Files['enc_rot_keys']
        if 'sign_secret_key' in keys2Files:
            self.__sign_secret_key = None
            self.sign_secret_key_file = keys2Files['sign_secret_key']
        if 'sign_public_key' in keys2Files:
            self.__sign_public_key = None
            self.sign_public_key_file = keys2Files['sign_public_key']
        if 'secret_key_shares' in keys2Files:
            self.__secret_key_shares = None
            self.secret_key_shares_file = keys2Files['secret_key_shares']

    #### ------------------------------------------------------------
    #### ------------------ KEY GENARATION METHODS ------------------
    #### ------------------------------------------------------------ 
    # @profile(precision=4, stream=open("memory_profiler_keygen.log", "w+"))
    def keyGen(self, np=None, sk_share_flag=False, rot_keys_num=1, eval_flag=True):
        ''' Generate the serect key and pubilc key. 
        '''

        # generate secret key and public key for signature
        global mklhs_scheme
        if not mklhs_scheme:
            mklhs_scheme = MKLHS_init()
        self.__sign_secret_key = LHSSKey()
        self.__sign_public_key = LHSPKey()
        mklhs_scheme.keyGen(self.__sign_secret_key, self.__sign_public_key, str(self.di_index))

        # generate secret key shares to servers and merge them to generate the dataisland's secret key
        assert ring
        key_generator = CKKSKeyGenerator(self.ckks_params)
        ## only one server: generate the encryption key for aggregation
        if self.sv_num == 1:
            # key for aggregating iterkey
            self.__secret_key  = key_generator.generate_secret_key()
            self.__secret_key_shares = None
            if sk_share_flag and self.di_threshold < self.di_num:
                # sk = interpolate(sk_sss)
                self.__secret_key_shares = self.secretkeySharesGen(threshold=self.di_threshold, np=np)
            self.__public_key = key_generator.generate_public_key(self.secret_key, fixedax_flag=True)
            # key for encrypting local model
            self.__enc_secret_key = key_generator.generate_secret_key()
            self.__enc_public_key = key_generator.generate_public_key(self.enc_secret_key, fixedax_flag=True)

        if eval_flag:
            self.__enc_relin_key = key_generator.generate_relin_key(self.enc_secret_key, fixedax_flag=True)
            self.__enc_rot_keys = key_generator.generate_rot_keys(self.enc_secret_key, fixedax_flag=True, rot_places=rot_keys_num)
            

    def secretkeySharesGen(self, secret_key=None, threshold=None, quantity=None, np=None):
        secret_key = secret_key if secret_key else self.secret_key
        threshold = threshold if threshold else self.threshold
        quantity = quantity if quantity else self.quantity

        if secret_key == self.secret_key and self.secret_key_shares:
            if not isinstance(self.secret_key_shares[0], SecretKey) or quantity<=threshold:
                return self.secret_key_shares
        
        # sk's shares is based on crt and modulus pVec
        # length of sk's share is Nnp=N*np (using pVec[:np] to crt sx which is ZZ(N) )
        secret_key_shares = []
        logq = self.ckks_params.logq
        np = np if np else ceil( (1+logq+logN+2) / pbnd )

        shares = SKShares(quantity, np)
        scheme.shareSecretKey(shares, secret_key, logq, quantity, threshold)
        secret_key_shares = [ shares.getRsxs(i) for i in range(quantity) ]
        return secret_key_shares


    def aggpublickeyGen(self, attend_di_index_list, save_flag=False):
        assert ring
        mod = nprimes
        agg_rbx = None
        di_indexs = attend_di_index_list
        for di_index in di_indexs:
            di_public_key = self.get_di_public_key(di_index)
            assert di_public_key
            rbx = di_public_key.rbx
            if agg_rbx:
                ring.addNTTAndEqual(agg_rbx, rbx, mod)
            else:
                agg_rbx = Uint64_t(rbx)
        agg_pk = Key(self.ckks_params.rax, agg_rbx)
        if save_flag:
            self.aggregation_public_key = agg_pk
        return agg_pk


    def iterkeyGen(self, update_flag=False, weight=None):
        ''' Generate key for encrypting local model

            di's iterkey = rv*rax*sk (mod q)
            # iterkey has total 65536 coeffs, max length of one coeff is 91
            # one coeff will be divided into x part, length of each part is ceil(91/x)
                # case1: one coeff will be divided into 8 part, length of each part is 12
                # case2: one coeff will be divided into 12 part, length of each part is 8 
            # for each coeff:
                # 1. padding '0' into the coeff's head to satisfy len(coeff)==91
                # 2. dividing coeff into x part:  91 = 11*5+12*3(case1) = 7*5+8*7(case2) 
                # 3. padding '0' into most important part's tail: 96 = (11+1)*5+12*3(case1) = (7+1)*5+8*7(case2) 
                # e.g.1.(in case1), coeff1(91) = 15475544537 02589716916 18897382922 49359566132 12519119416 745996053456 785003644857 998801763971
                # divided coeff1 = 154755445370, 025897169160, 188973829220, 493595661320, 125191194160, 745996053456, 785003644857, 998801763971
                # e.g.2.(in case1), coeff2(90) = 01547554453 70258971691 61889738292 24935956613 21251911941 674599605345 678500364485 799880176397
                # divided coeff = 015475544530, 702589716910, 618897382920, 249359566130, 212519119410, 674599605345, 678500364485, 799880176397
        
        '''
        if not self.enc_secret_key or update_flag:
            key_generator = CKKSKeyGenerator(self.ckks_params)
            self.__enc_secret_key = key_generator.generate_secret_key()
            self.__enc_public_key = key_generator.generate_public_key(self.enc_secret_key, fixedax_flag=True)
        assert ring

        logp, logq = self.ckks_params.logp, self.ckks_params.logq
        np = ceil( (1+logQQ+logN+2) / pbnd )
        int_q = int( ring.qpows[logq] )
        int_qQ = int( ring.qpows[logq+logQ] )
        q, qQ = ZZ( [int_q] ), ZZ( [int_qQ] )

        # sample random_vec
        random_vec, dec_part_coeffs = ZZ(N), ZZ(N)
        ring.sampleZO(random_vec)

        # compute dec_part_iteration = rv*rax*sk
        rax, sx = self.enc_public_key.rax, self.enc_secret_key.sx

        ring.multNTT(dec_part_coeffs, random_vec, rax, np, qQ)
        ring.rightShiftAndEqual(dec_part_coeffs, logQ)
        ring.multAndEqual(dec_part_coeffs, sx, np, q)
        if weight:
            weight_zz = ZZ( [weight] )
            ring.multByConstAndEqual(dec_part_coeffs, weight_zz, q)
        # ring.addGaussAndEqual(dec_part_coeffs, qQ)

        dec_part_coeffs_mlist = []
        for j in range(N):
            coeff = str(int(dec_part_coeffs[j]))
            coeff = '0'*(91-len(coeff)) + coeff

            # case1: 1 coeff divided into 8 parts: 91 = 11 * 5 + 12 * 3
            coeff_list = [ coeff[i*11:i*11+11]+'0' for i in range(5) ] + [ coeff[55+i*12:55+i*12+12] for i in range(3) ]
            coeff_complex_list = [ complex( int(coeff_list[i]), int(coeff_list[i+1]) ) for i in range(0,8,2) ]
            #---------

            # # case2: 1 coeff divided into 12 parts: 91 = 7 * 5 + 8 * 7
            # coeff_list = [ coeff[i*7:i*7+7]+'0' for i in range(5) ] + [ coeff[35+i*8:35+i*8+8] for i in range(7) ]
            # coeff_complex_list = [ complex( int(coeff_list[i]), int(coeff_list[i+1]) ) for i in range(0,12,2) ]
            # #---------

            dec_part_coeffs_mlist.extend(coeff_complex_list)

        self.enc_rv_iteration = random_vec
        self.dec_part_iteration = CKKSMessage(mlist=dec_part_coeffs_mlist, slots=self.ckks_params.slots)
        #del random_vec, dec_part_coeffs_mlist
        return self.dec_part_iteration
    #### ------------------------------------------------------------
    #### ------------------------------------------------------------

    #### ------------------------------------------------------------
    #### -------------------- ENCRYPTION METHODS --------------------
    #### ------------------------------------------------------------ 
    def encrypt(self, message, public_key=None, imag_flag=False, rv_flag=False, random_vec=None, thread_num=1, list_flag=False, n=None, logp=None, logq=None):
        ''' encrypt using encrytion public key (default: pk=self.enc_public_key for evaluation) 
            Args:
                message (list/CKKSMessage/ComplexDouble);
        '''
        slots = self.ckks_params.slots
        if isinstance(message, CKKSMessage) or isinstance(message, Plaintext):
            msg = message
        elif isinstance(message, list):
            if imag_flag:
                message = [ complex(message[i],message[i+1]) for i in range(0,len(message),2) ]
            msg = CKKSMessage(slots=slots, mlist=message)
        elif isinstance(message, ComplexDouble):
            msg = CKKSMessage(slots=slots, mvec=message)
        else:
            raise ValueError("Input message to encrypt must be a list/ComplexDouble/CKKSMessage")

        pk = public_key if public_key else self.enc_public_key
        encryptor = CKKSEncryptor(self.ckks_params, pk)
        n = n if n else self.ckks_params.n
        logp = logp if logp else self.ckks_params.logp
        logq = logq if logq else self.ckks_params.logq
        if random_vec:
            ciph = encryptor.encrypt(msg, random_vec=random_vec, thread_num=thread_num, list_flag=list_flag, n=n, logp=logp, logq=logq)
        elif rv_flag:
            if not self.enc_rv_iteration:
                self.enc_rv_iteration = ZZ(N)
                ring.sampleZO(self.enc_rv_iteration)
            #assert self.enc_rv_iteration
            ciph = encryptor.encrypt(msg, random_vec=self.enc_rv_iteration, thread_num=thread_num, list_flag=list_flag, n=n, logp=logp, logq=logq)
        else:
            ciph = encryptor.encrypt(msg, thread_num=thread_num, list_flag=list_flag, n=n, logp=logp, logq=logq)

        return ciph

    def encryptModel(self, model, soln, public_key=None):
        ''' encrypte model '''
        ciph_lm = self.encrypt(soln, public_key=public_key, rv_flag=True, thread_num=8, list_flag=False)
        return ciph_lm


    # @profile(precision=4, stream=open("memory_profiler_partEnc.log", "w+"))
    def partEncrypt(self, message, public_key=None, random_vec=None, thread_num=1):
        ''' part encrypt using public key (default: pk=self.aggregation_public_key for aggregation) 
            Args:
                message (list); 
        '''
        pk = public_key if public_key else self.aggregation_public_key
        partciph = self.encrypt(message, public_key=pk, random_vec=random_vec, thread_num=thread_num)
        return partciph


    def partEncIterkey(self, attend_di_index_list=None, aggregation_public_key=None, thread_num=8):
        ''' encrypte iterkey '''
        assert self.dec_part_iteration
        # set the aggregation_public_key
        if attend_di_index_list:
            self.aggregation_public_key = self.aggpublickeyGen(attend_di_index_list)
        elif aggregation_public_key:
            self.aggregation_public_key = aggregation_public_key
        assert self.aggregation_public_key

        partciph = self.partEncrypt(self.dec_part_iteration, thread_num=thread_num) # default 4 threads
        return partciph
    #### ------------------------------------------------------------
    #### ------------------------------------------------------------

    #### ------------------------------------------------------------
    #### -------------------- DECRYPTION METHODS --------------------
    #### ------------------------------------------------------------ 
    def decrypt(self, ciphertext, plain_flag=False, msg_flag=False, list_flag=True):
        ''' '''
        assert self.enc_secret_key
        decryptor = CKKSDecryptor(self.ckks_params, self.enc_secret_key)
        msg = decryptor.decrypt(ciphertext, plain_flag=plain_flag, msg_flag=msg_flag, list_flag=list_flag)
        return msg
    #### ------------------------------------------------------------
    #### ------------------------------------------------------------

    #### ------------------------------------------------------------
    #### ------------ PART DECRYPTION METHODS (USING SK) ------------
    #### ------------------------------------------------------------ 
    #### ------------ PART DECRYPTION (GETTING DECSHARES) -----------
    def __partDecrypt__(self, ciph_ax, np, q, sx):
        ''' '''
        assert isinstance(ciph_ax, ZZ)
        dec_share = ZZ(N)
        ring.mult(dec_share, ciph_ax, sx, np, q)
        #ring.multByConst(dec_share, ciph_ax, sx, q)
        return dec_share


    def partDecrypt(self, ciph_ax, sx=None, sx_sss=None, multi_flag=True):
        ''' '''
        sx = sx if sx else self.secret_key.sx
        if not isinstance(sx, ZZ):
            sx = data2Obj(sx, 'ZZ')

        assert ring and sx
        logq = self.ckks_params.logq
        q = ZZ( [ ring.qpows[logq] ] )
        np = ceil( (1+logq+logN+2) / pbnd )
        #np = ceil( (1+logQQ+logN+2) / pbnd )
        #q = ZZ( [skSharesMod] ) # share (mod skSharesMod)

        if isinstance(ciph_ax, ZZ): 
            return self.__partDecrypt__(ciph_ax, np, q, sx)

        elif isinstance(ciph_ax, list): 
            # default dec_shares of ax is the same, only compute once
            multi_flag = True if multi_flag and len(set(ciph_ax))>1 else False
            if not multi_flag:
                dec_shares = [ self.__partDecrypt__(ciph_ax[0], np, q, sx) ] * len(ciph_ax)
            else:
                dec_shares = [ self.__partDecrypt__(ax, np, q, sx) for ax in ciph_ax ]
            return dec_shares

        else:
            raise ValueError("Input to partDecrypt must be a ZZ or a list of ZZ.")
    #### ------------------------------------------------------------ 
    #### ------------------------------------------------------------ 
    #### ------------------------------------------------------------ 

    
    #### ------------------------------------------------------------
    #### -------- PART DECRYPTION METHODS (USING SK_SHARES) ---------
    #### ------------------------------------------------------------
    #### -------------------- SK SHARES METHODS ---------------------
    def getSKShares(self, di_inx, di_secret_key_shares=None):
        di_inxs = di_inx if isinstance(di_inx, list) else [di_inx]
        sk_shares = []
        try:
            for di_inx in di_inxs:
                rsx = di_secret_key_shares[di_inx] if di_secret_key_shares else self.get_di_secret_key_share(di_inx)
                if not isinstance(rsx, Uint64_t):
                    rsx = Uint64_t(list(rsx))
                sk_shares.append(rsx)
        except:
            raise ValueError('DI['+str(self.di_index)+'] has no share of DI['+str(di_inx)+']\'s secret key.')

        if len(sk_shares)==1:
            return sk_shares[0]
        else:
            return sk_shares

    def __sharesAggregate__(self, shamir_shares, np=None):
        ''' '''
        np = np if np else ceil( (1+self.ckks_params.logq+logN+2) / pbnd )
        agg_sss = Uint64_t([0]*N*np)
        for sss_i in shamir_shares:
            ring.multiplier.addNTTAndEqual(agg_sss, sss_i, np)
        return agg_sss
    #### ------------------------------------------------------------

    #### ---------- PART DECRYPTION (GETTING DECSHARES_SSS) ---------
    def __partDecshare__(self, ciph_ax, rsx, np):
        ''' '''
        assert isinstance(ciph_ax, ZZ) and isinstance(rsx, Uint64_t)
        decshare_sss = Uint64_t( N*np )
        ring.multiplier.multNTT(decshare_sss, ciph_ax, rsx, np)
        return decshare_sss

    def __partDecshares__(self, ciph_ax, rsx, np=None, multi_flag=-1):
        ''' '''
        # assert isinstance(rsx, Uint64_t)
        np = np if np else ceil( (1+self.ckks_params.logq+logN+2) / pbnd )

        if isinstance(ciph_ax, ZZ): 
            return self.__partDecshare__(ciph_ax, rsx, np)
        elif isinstance(ciph_ax, list):
            if multi_flag == -1:
                multi_flag = True if len(set(ciph_ax))>1 else False
            if not multi_flag: # default decshares_sss of ax is the same, only compute once
                decshares_sss = [ self.__partDecshare__(ciph_ax[0], rsx, np) ] * len(ciph_ax)
            else:
                decshares_sss = [ self.__partDecshare__(ax, rsx, np) for ax in ciph_ax ]
            return decshares_sss
        else:
            raise ValueError("Input ciph_ax to partDecrypt must be a ZZ or a list of ZZ.")


    def partDecshare(self, di_inx, ciph_ax, di_secret_key_shares=None, multi_flag=-1):
        ''' '''
        rsx = self.getSKShares(di_inx, di_secret_key_shares=di_secret_key_shares)
        return self.__partDecshares__(ciph_ax, rsx, multi_flag=multi_flag)


    def partAggDecshare(self, ciph_ax, di_inxs=None, di_secret_key_shares=None, multi_flag=-1):
        ''' '''
        if di_inxs:
            sk_shares_list = self.getSKShares(di_inxs, di_secret_key_shares=di_secret_key_shares)
            rsx = self.__sharesAggregate__(sk_shares_list)
        else:
            rsx = self.agg_sk_share
        return self.__partDecshares__(ciph_ax, rsx, multi_flag=multi_flag)
    #### ------------------------------------------------------------
    #### ------------------------------------------------------------
    #### ------------------------------------------------------------

    #### ------------------------------------------------------------
    #### -------------------- SIGNATURE METHODS ---------------------
    #### ------------------------------------------------------------ 
    def signature(self, msg, lhs_sk=None, msgs_num=0):
        ''' signature using lhs_sk '''
        lhs_sk = lhs_sk if lhs_sk else self.sign_secret_key
        assert(lhs_sk, LHSSKey)
        encoder = MKLHSEncoder()
        msg = encoder.encodeLHSMsgs(msg, msgs_num=msgs_num)
        sign = LHSSigns(msg.size)

        global mklhs_scheme
        if not mklhs_scheme:
            mklhs_scheme = MKLHS_init()
        mklhs_scheme.signMsgs(sign, msg, lhs_sk)
        return sign

    def signCiphtxts(self, ciphs, lhs_sk=None):
        ''' signature ciphtexts using lhs_sk '''
        lhs_sk = lhs_sk if lhs_sk else self.sign_secret_key
        assert(lhs_sk, LHSSKey)
        encoder = MKLHSEncoder()
        msg = encoder.ciphs2LHSMsgs(ciphs)
        sign = self.signature(msg)
        return sign

    def signCiphModel(self, ciph_lm):
        ''' signature local model ciphertxt '''
        assert self.sign_secret_key
        # signature local model
        lhsmsg_clm = modelCiph2LHSMsg(ciph_lm, self.ckks_params)
        sign_clm = self.signature(lhsmsg_clm)
        return sign_clm

    def signModel(self, model, lm_soln):
        ''' signature local model ciphertxt '''
        assert self.sign_secret_key
        # signature local model
        hash_lm = getModelSolnHash(model, lm_soln)
        sign_clm = self.signature(hash_lm)
        return sign_clm, hash_lm
    #### ------------------------------------------------------------
    #### ------------------------------------------------------------


    #### ------------------------------------------------------------
    #### ----------------- VERIFY SIGNATURE METHODS -----------------
    #### ------------------------------------------------------------ 
    def verSign(self, msg, sign, di_inx, weight=None):
        ''' verify one DI's signature using its lhs_pk '''
        pk = self.get_di_sign_public_key(di_inx)
        verifier = MKLHSVerifier()
        ver_res = verifier.verifyLHSign(msg, sign, pk, weight=weight)
        return ver_res

    def verCiphSumMKSign(self, ciph_sum, sign_csum, di_inxs, lhsmsg_ciphs, weights=None):
        ''' verify MKLHSigns using DIs' lhs_pks '''
        encoder = MKLHSEncoder()
        lhsmsg_csum = encoder.ciphs2LHSMsgs(ciph_sum)
        pks = [ self.get_di_sign_public_key(di_inx) for di_inx in di_inxs ]

        verifier = MKLHSVerifier()
        int_q = int(2**self.ckks_params.logq)
        # ver_res1: lhsmsg_csum == agg(lhsmsg_ciphs)
        ver_res1 = verifier.isMsgLinearity(lhsmsg_csum, lhsmsg_ciphs, weights=weights, mod=int_q)
        # ver_res2: sign_csum is signature of lhsmsg_ciphs by pks
        ver_res2 = verifier.verifyMKLHSign(lhsmsg_ciphs, sign_csum, pks, weights=weights)
        return ver_res1 and ver_res2


    def verGlobalModelMKSign(self, model, gm_soln, sign_gm, di_inxs, hash_lms, weights=None):
        ''' verify SV's signature of hash(gm) using dis' lhs_pk
            ( gm = sum([ lm[i] for i in di_inxs ]) 
        '''
        msg_len, msgs_num = len(gm_soln), len(di_inxs)
        weights = weights if weights else [1]*msgs_num
        lhh_scheme = LHH_init()

        hash_gm = getModelSolnHash(model, gm_soln)

        # ver_res1: hash(gm) == agg(hash(lm))
        lm_hashes = LHHHash()
        lhh_scheme.resetHashes(lm_hashes, msgs_num)
        alphas = LHHVal(msgs_num)
        for i in range(msgs_num):
            lhh_scheme.setHashes(lm_hashes, hash_lms[i], i)
            alphas.setVal(str(weights[i]), i)
        hash_lm_agg = LHHHash()
        lhh_scheme.evalHashes(hash_lm_agg, lm_hashes, alphas)
        ver_res1 = True if lhh_scheme.cmpHash(hash_lm_agg, hash_gm) else False
        # ver_res2: sign_gm is signature of hash_lms by pks
        pks = [ self.get_di_sign_public_key(di_inx) for di_inx in di_inxs ]
        verifier = MKLHSVerifier()
        ver_res2 = verifier.verifyMKLHSign(hash_lms, sign_gm, pks, weights=weights)
        return ver_res1 and ver_res2
    #### ------------------------------------------------------------
    #### ------------------------------------------------------------


    #### ------------------------------------------------------------
    #### -------------- VALIDATION DATASET GENERATION ---------------
    #### ------------------------------------------------------------ 
    def valDatasetGen(self, validation_dataset, save_flag=False):
        ''' '''
        # generate validation_ciph_dataset by enc_serect_key
        validation_ciph_dataset = []
        range_validation_dataset = validation_dataset
        for (x,y) in range_validation_dataset:
            ciph_x = self.encrypt(x.tolist())
            ciphs_y = [ self.encrypt([yi]) for yi in y ]
            validation_ciph_dataset.append( (ciph_x, ciphs_y) )
        if save_flag:
            self.validation_ciph_dataset = validation_ciph_dataset
        return validation_ciph_dataset
    #### ------------------------------------------------------------
    #### ------------------------------------------------------------
