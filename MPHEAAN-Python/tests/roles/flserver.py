'''server of federated learing.'''
from HEAAN import ZZ, Uint64_t, ComplexDouble, SecretKey, Key, Plaintext, Ciphertext, Ciphertexts, SKShares
from MKLHS import LHSSKey, LHSPKey

from mkTPFL.ckks.ckks_parameters import *
from mkTPFL.ckks.ckks_key_generator import CKKSKeyGenerator
from mkTPFL.ckks.ckks_encoder import CKKSMessage, CKKSEncoder
from mkTPFL.ckks.ckks_encryptor import CKKSEncryptor
from mkTPFL.ckks.ckks_decryptor import CKKSDecryptor
from mkTPFL.ckks.ckks_evaluator import CKKSEvaluator

from mkTPFL.mklhs.mklhs_parameters import *
from mkTPFL.mklhs.mklhs_encoder import MKLHSEncoder, modelCiph2LHSMsg
from mkTPFL.mklhs.mklhs_verifier import MKLHSVerifier

from mkTPFL.utils.class_transformer import getData, DataLHSSKey, DataLHSPKey, DataSecretKey, DataKey, DataZZ, data2Obj, getCiphsBX, getCiphsParams

from math import ceil, floor
import numpy
import random
from collections import defaultdict
import time

class FLServer:
    ''' Privacy-preserving Federated Learning Server: 
        An role who takes charge of aggregating local models to get global model.

    Attributes:
        sv_index: index of this server. 
        
        # number & threshold of roles
        sv_num: number of all servers (SVs). 
        sv_threshold: minimum number of SVs needed to recover secretsã€‚
            (this simple version only supports single server case. i.e., sv_num = sv_threshold = 1.)
        di_num: number of all data islands (DIs).
        di_threshold: minimum number of DIs needed to recover the secret. 
            (i.e., the number of attended DIs in one aggregation must over di_threshold.)
        
        # about CKKS encryption
        ckks_params: public parameter of CKKS scheme.
        (secret_key, public_key): basic CKKS key pair of this SV.
            (this simple version does not use this key. i.e., (secret_key, public_key) = (None, None).)
        di_secret_key_shares: shamir shares of all DIs' secret_keys holded by this SV.
            (this simple version does not use these shares. i.e., di_secret_key_shares = None.)
        di_public_keys: 
            public_keys corresponding to all DIs' secret_keys.
        (di_enc_public_keys, di_enc_relin_keys, di_enc_rot_keys): 
            (public_keys, relin_keys, rot_keys) corresponding to all DIs' enc_secret_keys.
            (i.e., the validation SV used it to evaluate the DIs' encrypted local models by di_validation_ciph_datasets.)
        aggregation_public_key: 
            the public key generated by aggregating attended DIs' public_keys in one iteration. 
            (i.e., each attened DI used it to encrypt its iter_key in one iteration.)
        di_validation_ciph_datasets:
            the validation_datasets is the ciphertexts of samples.
            (i.e., each DI selects some samples randomly from original trainning dataset,
                and using its enc_public_key to encrypte these samples to get its validation_dataset in setup phase.)
        
        # about MKLHS signuature
        mklhs_params: public parameter of MKLHS scheme.
        di_sign_public_keys:
            public_keys corresponding to all DIs' sign_secret_keys.

    Methods:
        # KEY GENARATION METHODS
        # ENCRYPTION METHODS        
        # DECRYPTION METHODS
        # PART DECRYPTION METHODS
        # CIPHERTEXTS AGGREGATION METHODS
        # SHARES RECOVER METHODS
        # GET GLOBAL MODEL METHODS
        # EVALUATION MODEL METHODS
        # VERIFY SIGNATURE METHODS
        # EVALUATION SIGNATURE METHODS
        
    '''
    def __init__(self, sv_index, di_num=None, sv_num=None, di_threshold=None, sv_threshold=None,
                    ckks_params=None, 
                    secret_key=None, public_key=None, di_secret_key_shares=None, 
                    di_public_keys=None, aggregation_public_key=None, 
                    di_enc_public_keys=None, di_enc_relin_keys=None, di_enc_rot_keys=None,
                    mklhs_params=None, di_sign_public_keys=None, 
                    di_validation_ciph_datasets=None, prediction_test_num=10):
        ''' Initializes PFL Server. '''
        self.sv_index = sv_index
        self.di_num = di_num
        self.sv_num = sv_num
        self.di_threshold = di_threshold if di_threshold else self.di_num
        self.sv_threshold = sv_threshold if sv_threshold else self.sv_num
        
        self.ckks_params = ckks_params
        self.__secret_key = secret_key
        self.__public_key = public_key
        self.__di_public_keys = di_public_keys
        self.__di_enc_public_keys = di_enc_public_keys
        self.__di_enc_relin_keys = di_enc_relin_keys 
        self.__di_enc_rot_keys = di_enc_rot_keys
        self.__di_secret_key_shares = di_secret_key_shares # for the case: multiple SVs (> 2 SVs)

        self.mklhs_params = mklhs_params
        self.__di_sign_public_keys = di_sign_public_keys

        # keys from file
        self.secret_key_file = None
        self.public_key_file = None
        self.di_public_keys_file = None
        self.di_enc_public_keys_file = None
        self.di_enc_relin_keys_file = None 
        self.di_enc_rot_keys_file = None
        self.di_secret_key_shares_file = None
        self.di_secret_key_shares_dir = None
        self.di_sign_public_keys_file = None

        self.di_validation_ciph_datasets = di_validation_ciph_datasets
        self.prediction_test_num = prediction_test_num

        # each iteration
        self.aggregation_public_key = aggregation_public_key

        

    @property
    def threshold(self):
        if self.sv_num == 1:
            threshold = self.di_threshold if self.di_threshold else self.di_num
        else:
            threshold = self.sv_threshold if self.sv_threshold else self.sv_num
        return threshold

    @property
    def secret_key(self):
        if self.__secret_key:
            return self.__secret_key
        elif self.secret_key_file:
            sk_data = getData(file_path=self.secret_key_file)
            return data2Obj(sk_data, 'SecretKey')
        else:
            return None

    @property
    def public_key(self):
        if self.__public_key:
            return self.__public_key
        elif self.public_key_file:
            key_data = getData(file_path=self.public_key_file)
            return data2Obj(key_data, 'Key')
        else:
            return None

    @property
    def di_public_keys(self):
        if self.__di_public_keys:
            return self.__di_public_keys
        elif self.di_public_keys_file:
            keys_data = [ getData(file_path=key_file) for key_file in self.di_public_keys_file ]
            return [ data2Obj(key_data, 'Key') for key_data in keys_data ]
        else:
            return None

    def get_di_public_key(self, i):
        if self.__di_public_keys:
            return self.__di_public_keys[i]
        elif self.di_public_keys_file:
            key_data = getData(file_path=self.di_public_keys_file[i])
            return data2Obj(key_data, 'Key')
        else:
            return None

    @property
    def di_enc_public_keys(self):
        if self.__di_enc_public_keys:
            return self.__di_enc_public_keys 
        elif self.di_enc_public_keys_file:
            keys_data = [ getData(file_path=key_file) for key_file in self.di_enc_public_keys_file ]
            return [ data2Obj(key_data, 'Key') for key_data in keys_data ]
        else:
            return None

    @property
    def di_enc_relin_keys(self):
        if self.__di_enc_relin_keys:
            return self.__di_enc_relin_keys 
        elif self.di_enc_relin_keys_file:
            keys_data = [ getData(file_path=key_file) for key_file in self.di_enc_relin_keys_file ]
            return [ data2Obj(key_data, 'Key') for key_data in keys_data ]
        else:
            return None

    @property
    def di_enc_rot_keys(self):
        if self.__di_enc_rot_keys:
            return self.__di_enc_rot_keys 
        elif self.di_enc_rot_keys_file:
            keys_datas = [ getData(file_path=key_file) for key_file in self.di_enc_rot_keys_file ]
            keys = []
            for keys_data in keys_datas:
                keys.append( [ data2Obj(key_data, 'Key')  for key_data in keys_data ] )
            return keys
        else:
            return None

    @property
    def di_sign_public_keys(self):
        if self.__di_sign_public_keys:
            return self.__di_sign_public_keys
        elif self.di_sign_public_keys_file:
            keys_data = [ getData(file_path=key_file) for key_file in self.di_sign_public_keys_file ]
            return [ data2Obj(key_data, 'LHSPKey') for key_data in keys_data ]
        else:
            return None

    def get_di_sign_public_key(self, i):
        if self.__di_sign_public_keys:
            return self.__di_sign_public_keys[i]
        elif self.di_sign_public_keys_file:
            key_data = getData(file_path=self.di_sign_public_keys_file[i])
            return data2Obj(key_data, 'LHSPKey')
        else:
            return None

    def set_di_secret_key_shares(self, di_secret_key_shares_list):
        if isinstance(di_secret_key_shares_list[0], str):
            self.__di_secret_key_shares = None
            self.di_secret_key_shares_file = di_secret_key_shares_list
        else:
            self.__di_secret_key_shares = di_secret_key_shares_list
            self.di_secret_key_shares_file = None

    def set_di_public_keys(self, di_public_keys_list):
        if isinstance(di_public_keys_list[0], Key):
            self.__di_public_keys = di_public_keys_list
            self.di_public_keys_file = None
        else:
            self.__di_public_keys = None
            self.di_public_keys_file = di_public_keys_list

    def set_di_enc_public_keys(self, di_enc_public_keys_list):
        if isinstance(di_enc_public_keys_list[0], Key):
            self.__di_enc_public_keys = di_enc_public_keys_list
            self.di_enc_public_keys_file = None
        else:
            self.__di_enc_public_keys = None
            self.di_enc_public_keys_file = di_enc_public_keys_list

    def set_di_enc_relin_keys(self, di_enc_relin_keys_list):
        if isinstance(di_enc_relin_keys_list[0], Key):
            self.__di_enc_relin_keys = di_enc_relin_keys_list
            self.di_enc_relin_keys_file = None
        else:
            self.__di_enc_relin_keys = None
            self.di_enc_relin_keys_file = di_enc_relin_keys_list

    def set_di_enc_rot_keys(self, di_enc_rot_keys_list):
        if isinstance(di_enc_rot_keys_list[0], str):
            self.__di_enc_rot_keys = None
            self.di_enc_rot_keys_file = di_enc_rot_keys_list
        else:
            self.__di_enc_rot_keys = di_enc_rot_keys_list
            self.di_enc_rot_keys_file = None

    def set_di_sign_public_keys(self, di_sign_public_keys_list):
        if isinstance(di_sign_public_keys_list[0], LHSPKey):
            self.__di_sign_public_keys = di_sign_public_keys_list
            self.di_sign_public_keys_file = None
        else:
            self.__di_sign_public_keys = None
            self.di_sign_public_keys_file = di_sign_public_keys_list


    def resetKeys2Files(self, keys2Files):
        if 'secret_key' in keys2Files:
            self.__secret_key = None
            self.secret_key_file = keys2Files['secret_key']
        if 'public_key' in keys2Files:
            self.__public_key = None
            self.public_key_file = keys2Files['public_key']


    def getObjFromFile(self, file_path, class_type):
        begin_time = time.time()
        res_obj = getObjFromFile(file_path, class_type)
        res_time = time.time()-begin_time
        return res_obj, res_time


    #### ------------------------------------------------------------
    #### ------------------ KEY GENARATION METHODS ------------------
    #### ------------------------------------------------------------ 
    def keyGen(self, attend_di_index_list=None, di_secret_key_shares=None):
        ''' Generate the serect key and pubilc key. '''
        # only one server: no di_secret_key_shares
        if self.sv_num == 1:
            self.secret_key = None
            self.public_key = None
            self.di_secret_key_shares = None

        # multipl servers: merge the di_secret_keys to generated server's secert key
        elif attend_di_index_list or di_secret_key_shares:
            # attend_di_index_list = attend_di_index_list if attend_di_index_list else [x for x in range(0,self.di_num)]
            # di_secret_key_shares = di_secret_key_shares if di_secret_key_shares else self.di_secret_key_shares
            # assert attend_di_index_list and di_secret_key_shares

            # Generated the server's secret key by aggregation
            self.__secret_key = self.aggsecretkeyGen(attend_di_index_list=attend_di_index_list, di_secret_key_shares=di_secret_key_shares)
            # Generated the server's public key by aggregation
            key_generator = CKKSKeyGenerator(self.ckks_params)
            self.__public_key = key_generator.generate_public_key(self.secret_key, fixedax_flag=True)

    def aggpublickeyGen(self, attend_di_index_list, save_flag=False):
        assert ring
        mod = nprimes
        agg_rbx = None
        di_indexs = attend_di_index_list
        for di_index in di_indexs:
            di_public_key = self.get_di_public_key(di_index)
            assert di_public_key
            rbx = di_public_key.rbx
            if agg_rbx:
                ring.addNTTAndEqual(agg_rbx, rbx, mod)
            else:
                agg_rbx = Uint64_t(rbx)
        agg_pk = Key(self.ckks_params.rax, agg_rbx)
        if save_flag:
            self.aggregation_public_key = agg_pk
        return agg_pk
    #### ------------------------------------------------------------
    #### ------------------------------------------------------------


    #### ------------------------------------------------------------
    #### -------------------- ENCRYPTION METHODS --------------------
    #### ------------------------------------------------------------ 
    def encryptByDIPubkey(self, message, di_index, random_vec=None, imag_flag=False, thread_num=1, transdata_flag=False):
        ''' '''
        assert self.di_enc_public_keys[di_index]
        encryptor = CKKSEncryptor(self.ckks_params, self.di_enc_public_keys[di_index])

        slots = self.ckks_params.slots
        if isinstance(message, CKKSMessage):
            msg = message
        elif isinstance(message, list):
            if imag_flag:
                message = [ complex(message[i],message[i+1]) for i in range(0,len(message),2) ]
            msg = CKKSMessage(slots=slots, mlist=message)
        elif isinstance(message, ComplexDouble):
            msg = CKKSMessage(slots=slots, mvec=message)
        else:
            raise ValueError("Input message to encrypt must be a list/ComplexDouble*/CKKSMessage")

        ciph = encryptor.encrypt(msg, random_vec=random_vec, thread_num=thread_num)

        if transdata_flag:
            ciph = DataCiphertext(ciph)

        return ciph


    def encrypt(self, message, public_key=None, imag_flag=False, rv_flag=False, thread_num=1, list_flag=False):
        ''' encrypt using encrytion public key (default: pk=self.aggregation_public_key for plaintxt signature) 
            Args:
                message (list); 
        '''
        slots = self.ckks_params.slots 
        if isinstance(message, CKKSMessage) or isinstance(message, Plaintext):
            msg = message
        elif isinstance(message, list):
            if imag_flag:
                message = [ complex(message[i],message[i+1]) for i in range(0,len(message),2) ]
            msg = CKKSMessage(slots=slots, mlist=message)
        elif isinstance(message, ComplexDouble):
            msg = CKKSMessage(slots=slots, mvec=message)
        else:
            raise ValueError("Input message to encrypt must be a list/ComplexDouble*/CKKSMessage")

        pk = public_key if public_key else self.aggregation_public_key
        encryptor = CKKSEncryptor(self.ckks_params, pk)

        if rv_flag:
            if not self.enc_rv_iteration:
                self.enc_rv_iteration = ZZ(N)
                ring.sampleZO(self.enc_rv_iteration)
            #assert self.enc_rv_iteration
            ciph = encryptor.encrypt(msg, random_vec=self.enc_rv_iteration, thread_num=thread_num, list_flag=list_flag)
        else:
            ciph = encryptor.encrypt(msg, thread_num=thread_num, list_flag=list_flag)

        return ciph
    #### ------------------------------------------------------------
    #### ------------------------------------------------------------

    #### ------------------------------------------------------------
    #### ------------- CIPHERTEXTS AGGREGATION METHODS --------------
    #### ------------------------------------------------------------ 
    def __ciphAggregate__(self, ciphertexts, evaluator=None, weights=None, eval_time_flag=False):
        ''' '''
        # if not isinstance(ciphertexts[0], Ciphertext):
        #     ciphertexts = [ data2Obj(ciph, 'Ciphertext') for ciph in ciphertexts ] 
        #assert isinstance(ciphertexts[0], Ciphertext)
        begin_time = time.time()
        sum_read_time = 0

        if not evaluator:
            evaluator = CKKSEvaluator(self.ckks_params)
            
        ciph_sum = evaluator.sum(ciphertexts, weights=weights)
        if not eval_time_flag:
            return ciph_sum
        else:
            return ciph_sum, time.time()-begin_time-sum_read_time

    def ciphAggregate(self, ciphertexts, weights=None):
        ''' '''
        if isinstance(ciphertexts, dict) and isinstance(weights, dict):
            ciphs, ws = [], []
            for inx,ciph in ciphertexts.items():
                ciphs.append(ciph)
                ws.append(weights[inx])
            ciphertexts, weights = ciphs, ws
        elif isinstance(ciphertexts, dict):
            ciphertexts = list(ciphertexts.values())

        evaluator = CKKSEvaluator(self.ckks_params)
        if isinstance(ciphertexts[0], Ciphertext) or isinstance(ciphertexts[0], Ciphertexts) or isinstance(ciphertexts[0], str): 
            return self.__ciphAggregate__(ciphertexts, evaluator=evaluator, weights=weights)

        elif isinstance(ciphertexts[0], list):
            party_num, ciphs_num = len(ciphertexts), len(ciphertexts[0])
            multi_ax_flag = True if len(set([ ciph.ax for ciph in ciphertexts[0] ]))>1 else False

            ciph_sums = []
            range_ciphs_num = range(ciphs_num)
            for i in range_ciphs_num:
                ciphtxts = [ ciphertexts[j][i] for j in range(party_num) ]
                if i==0 or multi_ax_flag:
                    ciph_sum = self.__ciphAggregate__(ciphtxts, evaluator=evaluator, weights=weights, fixedax_flag=False)
                else:
                    ciph_sum = self.__ciphAggregate__(ciphtxts, evaluator=evaluator, weights=weights, fixedax_flag=True)
                ciph_sums.append(ciph_sum)
            return ciph_sums

        else:
            raise ValueError("Input of ciphAggregate must be list(s) of Ciphertext.")

    def ciphModelAggregate(self, ciph_lm_dict, weight_dict=None):
        ''' aggregation ciphertexts of models '''
        ciphs_lm, weights = [], []
        if weight_dict:
            for di_inx in ciph_lm_dict.keys():
                ciph_lm = ciph_lm_dict[di_inx]
                weight = weight_dict[di_inx]
                ciphs_lm.append(ciph_lm)
                weights.append(weight)
        else:
            ciphs_lm, weights = list(ciph_lm_dict.values()), None

        ciph_gm = self.ciphAggregate(ciphs_lm, weights=weights)
        return ciph_gm
    #### ------------------------------------------------------------
    #### ------------------------------------------------------------ 


    #### ------------------------------------------------------------
    #### -------------------- DECRYPTION METHODS --------------------
    #### ------------------------------------------------------------
    # def decrypt(self, ciphertext, attend_di_index_list=None, msg_flag=False):
    #     ''' '''
    #     if not attend_di_index_list:
    #         secret_key = self.secret_key
    #     else:
    #         secret_key = self.aggsecretkeyGen(attend_di_index_list=attend_di_index_list)
    #     assert secret_key
    #     decryptor = CKKSDecryptor(self.ckks_params, secret_key)
    #     msg = decryptor.decrypt(ciphertext, msg_flag=msg_flag)
    #     return msg
    #### ------------------------------------------------------------
    #### ------------------------------------------------------------ 


    #### ------------------------------------------------------------
    #### -------------- DECRYPTION METHODS (USING ITK) --------------
    #### ------------------------------------------------------------ 
    #### ------------------ GETTING ITERKEY METHOD ------------------
    def getIterkey(self, ciph_sum, decshare_list, save_flag=False):
        ''' '''
        iterkey_msg = self.decshareMerge(ciph_sum, decshare_list)

        iterkey_coeffs = []
        for mvec in iterkey_msg.vectors:
            for i in range(self.ckks_params.slots):
                data = mvec.__getitem__(i)
                iterkey_coeffs.extend( [float(str(data.real())), float(str(data.imag()))] )

        # case1: 1 coeff divided into 8 part: 91 = 11 * 5 + 12 * 3
        assert len(iterkey_coeffs) == N*8
        iterkey_coeffs_list = []
        for i in range(N):
            coeff = 0
            coeff_list = iterkey_coeffs[i*8:i*8+8]
            coeff_list.reverse()
            for j in range(7,-1,-1):
                if j >= 3 : 
                    coeff += ( round(coeff_list[j]/10) * (10**(36+11*(j-3))) )
                else:
                    coeff += ( round(coeff_list[j]) * (10**(12*j)) )
            iterkey_coeffs_list.append( int(coeff) )
        #---------

        # # case2: 1 coeff divided into 12 part: 91 = 7 * 5 + 8 * 7
        # assert len(iterkey_coeffs) == N*12
        # iterkey_coeffs_list = []
        # for i in range(N):
        #     coeff = 0
        #     coeff_list = iterkey_coeffs[i*12:i*12+12]
        #     coeff_list.reverse()
        #     for j in range(11,-1,-1):
        #         if j >= 7 : 
        #             coeff += ( round(coeff_list[j]/10) * (10**(56+7*(j-7))) )
        #         else:
        #             coeff += ( round(coeff_list[j]) * (10**(8*j)) )
        #     iterkey_coeffs_list.append( int(coeff) )
        # #---------

        iterkey = ZZ(iterkey_coeffs_list)
        if save_flag:
            self.iterkey = iterkey
        return iterkey
    #### ------------------------------------------------------------ 

    #### -------------- DECRYPTION METHODS (USING ITK) --------------
    def __decryptByIterkey__(self, bx, logp, logq, n, iterkey=None, plain_flag=False, msg_flag=True):
        ''' '''
        q = ZZ( [int(ring.qpows[logq])] )
        iterkey = iterkey if iterkey else self.iterkey
        if not isinstance(iterkey, ZZ):
            iterkey = ZZ(iterkey)
        assert ring and iterkey

        ring.modAndEqual(iterkey, q)
        mx = ZZ(N)
        ring.add(mx, iterkey, bx, q)
        plain = Plaintext(mx, logp, logq, n)

        if plain_flag: # return plaintext
            return plain
        else: # return ckks_msg(msg_flag=msg_flag) or mvec(msg_flag=False)
            encoder = CKKSEncoder(self.ckks_params)
            msg = encoder.decode(plain, msg_flag=msg_flag)
            return msg

    def decryptByIterkey(self, ciphertext, iterkey=None, plain_flag=False, msg_flag=True):
        ''' '''
        if isinstance(ciphertext, Ciphertext):
            bx, logp, logq, n = ciphertext.bx, ciphertext.logp, ciphertext.logq, ciphertext.n
            return [ self.__decryptByIterkey__(bx, logp, logq, n, iterkey=iterkey, plain_flag=plain_flag, msg_flag=msg_flag) ]
        else:
            dec_res = []
            ciphs_num, logp, logq, n = getCiphsParams(ciphertext)
            range_ciphs_num = range(ciphs_num)
            for i in range_ciphs_num:
                bx = getCiphsBX(ciphertext, i)
                dec_res.append( self.__decryptByIterkey__(bx, logp, logq, n, iterkey=iterkey, plain_flag=plain_flag, msg_flag=msg_flag) )
            return dec_res
    #### ------------------------------------------------------------
    #### ------------------------------------------------------------
    #### ------------------------------------------------------------

    #### ------------------------------------------------------------
    #### ------------ PART DECRYPTION METHODS (USING SK) ------------
    #### ------------------------------------------------------------ 
    #### ------------ PART DECRYPTION (GETTING DECSHARES) -----------
    def __partDecrypt__(self, ciph_ax, np, q, sx):
        ''' '''
        assert isinstance(ciph_ax, ZZ)
        dec_share = ZZ(N)
        ring.mult(dec_share, ciph_ax, sx, np, q)
        return dec_share

    def partDecrypt(self, ciph_ax, di_index=None, attend_di_index_list=None, sx=None, sx_sss=None, multi_flag=False):
        ''' '''
        if not sx:
            if di_index != None:
                sk = self.di_secret_key_shares[di_index]
            elif attend_di_index_list != None:
                sk = self.aggsecretkeyGen(attend_di_index_list=attend_di_index_list)
            else:
                sk = self.secret_key
            sx = sk.sx
        logq = self.ckks_params.logq
        q = ZZ( [ ring.qpows[logq] ] )
        np = ceil( (1+logq+logN+2) / pbnd )

        if isinstance(ciph_ax, ZZ): 
            return self.__partDecrypt__(ciph_ax, np, q, sx)
        elif isinstance(ciph_ax, list): 
            # default dec_shares of ax is the same, only compute once
            if not multi_flag:
                dec_shares = [ self.__partDecrypt__(ciph_ax[0], np, q, sx) ] * len(ciph_ax)
            else:
                dec_shares = [ self.__partDecrypt__(ax, np, q, sx) for ax in ciph_ax ]
            return dec_shares
        else:
            raise ValueError("Input of partDecrypt must be a ZZ or a list of ZZ.")
    #### ------------------------------------------------------------ 
    
    #### -------------------- DECSHARES METHODS ---------------------
    ### -- DECSHARES MERGE
    def __decshareMerge__(self, ciph_sum_bx, logp, logq, n, dec_shares, plain_flag=False, msg_flag=True):
        ''' '''
        assert ring and isinstance(dec_shares[0], ZZ)
        # logp, logq, n = ciph_sum.logp, ciph_sum.logq, ciph_sum.n
        q = ZZ( [ ring.qpows[logq] ] )
        
        sum_mx = ZZ(N)
        ring.addAndEqual(sum_mx, ciph_sum_bx, q)
        for dec_share in dec_shares:
            ring.addAndEqual(sum_mx, dec_share, q)
        plain = Plaintext(sum_mx, logp, logq, n)

        if plain_flag: # return plaintext
            return plain
        else: # return ckks_msg(msg_flag=msg_flag) or mvec(msg_flag=False)
            encoder = CKKSEncoder(self.ckks_params)
            msg = encoder.decode(plain, msg_flag=msg_flag)
            return msg
    
    def decshareMerge(self, ciph_sum, dec_shares, plain_flag=False, msg_flag=True):
        ''' '''
        # only merge dec_shares
        if not ciph_sum: 
            assert isinstance(dec_shares[0], ZZ)
            q = ZZ( [ ring.qpows[self.ckks_params.logq] ] )
            ds_sum = ZZ(N)
            for dec_share in dec_shares:
                ring.addAndEqual(ds_sum, dec_share, q)
            return ds_sum

        # 1 ciphertext & 1 decshare
        elif isinstance(ciph_sum, Ciphertext): 
            if isinstance(dec_shares, ZZ):  
                dec_shares = [dec_shares]
            if not isinstance(dec_shares[0], ZZ):
                raise ValueError("Input of dec_shares in decshareMerge must be list(s) of ZZ.")
            bx, logp, logq, n = ciph_sum.bx, ciph_sum.logp, ciph_sum.logq, ciph_sum.n
            return self.__decshareMerge__(bx, logp, logq, n, dec_shares, plain_flag=plain_flag, msg_flag=msg_flag)

        # n ciphertexts or 1 ciphertexts (ciphertexts.size=n)
        elif (isinstance(ciph_sum, list) and isinstance(ciph_sum[0], Ciphertext)) or isinstance(ciph_sum, Ciphertexts): 
            ciphs_num, logp, logq, n = getCiphsParams(ciph_sum)
            msgs = []
            if isinstance(dec_shares[0], ZZ): # n ciphertexts corresponding to n decshares
                for i in range(ciphs_num):
                    bx = getCiphsBX(ciph_sum, i)
                    msg = self.__decshareMerge__(bx, logp, logq, n, [dec_shares[i]], plain_flag=plain_flag, msg_flag=msg_flag)
                    msgs.append(msg)
            elif isinstance(dec_shares[0], list): # n ciphertexts corresponding to n*n decshares
                assert len(dec_shares[0]) == ciphs_num
                party_num = len(dec_shares)
                for i in range(ciphs_num):
                    shares = [ dec_shares[j][i] for j in range(party_num) ]
                    bx = getCiphsBX(ciph_sum, i)
                    msg = self.__decshareMerge__(bx, logp, logq, n, shares, plain_flag=plain_flag, msg_flag=msg_flag)
                    msgs.append(msg)
            else:
                raise ValueError("Inputting of dec_shares in decshareMerge must be list(s) of ZZ.")
            
            if msg_flag:
                return CKKSMessage(msglist=msgs)
            else:
                return msgs
        
        else:
            raise ValueError("Input of ciph_sum in decshareMerge must be Ciphertext(s).")
            

    ### -- AGGDECSHARES MERGE
    def getAggDecshare(self, ciphs_dict):
        ''' '''
        decshares = []
        for di_inx,ciph in ciphs_dict.items():
            ciph_ax = getCiphsAXs(ciph)
            multi_flag = True if isinstance(ciph_ax,list) and set(ciph_ax)>1 else False
            # ciph_ax = ciph.ax if isinstance(ciph, Ciphertext) else [ ciph_i.ax for ciph_i in ciph ]
            # multi_flag = False if isinstance(ciph, Ciphertext) or set(ciph_ax)==1 else True
            decshare = self.partDecrypt(ciph_ax, di_index=di_inx, multi_flag=multi_flag)
            decshares.append(decshare)
            
        if isinstance(decshares[0], list): # one value of ciphs_dict contains multiple ciphertexts
            decshares_list = numpy.array(decshares).T
            return [ self.decshareMerge(None, decshares_) for decshares_ in decshares_list ]
        else: # one value of ciphs_dict contains single ciphertext
            return self.decshareMerge(None, decshares)
    #### ------------------------------------------------------------
    #### ------------------------------------------------------------
    #### ------------------------------------------------------------


    #### ------------------------------------------------------------
    #### -------- PART DECRYPTION METHODS (USING SK_SHARES) ---------
    #### ------------------------------------------------------------
    #### -------------------- SK SHARES METHODS ---------------------
    def getSKShares(self, di_inx, di_secret_key_shares=None):
        di_secret_key_shares = di_secret_key_shares if di_secret_key_shares else self.di_secret_key_shares
        di_inxs = di_inx if isinstance(di_inx, list) else [di_inx]
        sk_shares = []
        try:
            for di_inx in di_inxs:
                rsx = di_secret_key_shares[di_inx]
                if not isinstance(rsx, Uint64_t):
                    rsx = Uint64_t(list(rsx))
                sk_shares.append(rsx)
        except:
            raise ValueError('SV['+str(self.sv_index)+'] has no share of DI['+str(di_inx)+']\'s secret key.')

        if len(sk_shares)==1:
            return sk_shares[0]
        else:
            return sk_shares

    def __sharesAggregate__(self, shamir_shares, np=None):
        ''' '''
        shamir_shares = shamir_shares if isinstance(shamir_shares, list) else [shamir_shares]
        np = np if np else ceil( (1+self.ckks_params.logq+logN+2) / pbnd )
        agg_sss = Uint64_t([0]*N*np)
        for sss_i in shamir_shares:
            ring.multiplier.addNTTAndEqual(agg_sss, sss_i, np)
        return agg_sss
    #### ------------------------------------------------------------

    #### ---------- PART DECRYPTION (GETTING DECSHARES_SSS) ---------
    def __partDecshare__(self, ciph_ax, rsx, np, weight=None):
        ''' '''
        assert isinstance(ciph_ax, ZZ) and isinstance(rsx, Uint64_t)
        decshare_sss = Uint64_t( N*np ) if not weight else Uint64_t( [weight]*N*np )
        ring.multiplier.multNTT(decshare_sss, ciph_ax, rsx, np)
        return decshare_sss

    def __partDecshares__(self, ciph, rsx, np=None, multi_flag=-1, weights=None):
        ''' '''
        # assert isinstance(rsx, Uint64_t)
        np = np if np else ceil( (1+self.ckks_params.logq+logN+2) / pbnd )
        if isinstance(ciph, Ciphertext):
            ciph_ax = ciph.ax
        elif isinstance(ciph, list) and isinstance(ciph[0], Ciphertext):
            ciph_ax = [c.ax for c in ciph]
        else:
            ciph_ax = ciph

        if isinstance(ciph_ax, ZZ): 
            return self.__partDecshare__(ciph_ax, rsx, np, weight=weights)

        elif isinstance(ciph_ax, list):
            if multi_flag == -1:
                multi_flag = True if len(set(ciph_ax))>1 else False
            if not multi_flag: # default decshares_sss of ax is the same, only compute once
                decshares_sss = [ self.__partDecshare__(ciph_ax[0], rsx, np, weight=weights) ] * len(ciph_ax)
            else:
                weights = weights if isinstance(weights,list) else [weights]*len(ciph_ax)
                decshares_sss = [ self.__partDecshare__(ciph_ax[i], rsx, np, weight=weights[i]) for i in range(len(ciph_ax)) ]
            return decshares_sss
        else:
            raise ValueError("Input ciph_ax to partDecrypt must be a ZZ or a list of ZZ.")


    def partDecshare(self, di_inx, ciph, di_secret_key_shares=None, multi_flag=-1, weight=None):
        ''' '''
        rsx = self.getSKShares(di_inx, di_secret_key_shares=di_secret_key_shares)
        return self.__partDecshares__(ciph, rsx, multi_flag=multi_flag, weights=weight)


    def partAggDecshare(self, ciph_dict, di_secret_key_shares=None, multi_flag=-1, weight_dict=None):
        ''' '''
        weight_dict = weight_dict if weight_dict else defaultdict(lambda:None)

        decshare_sss_list = []
        for di_inx, ciph in ciph_dict.items():
            decshare_sss = self.partDecshare(di_inx, ciph, di_secret_key_shares=di_secret_key_shares, multi_flag=multi_flag, weight=weight_dict[di_inx])
            decshare_sss_list.append(decshare_sss)
        return self.__sharesAggregate__(decshare_sss_list)
    #### ------------------------------------------------------------
    #### ------------------------------------------------------------


    #### ------------------------------------------------------------
    #### ----------------- SHARES RECOVER METHODS -------------------
    #### ------------------------------------------------------------ 
    def __shareRecover__(self, shamir_shares, modulus, threshold, value_type, reconstruct_flag=False, np=None, mod=None):
        ''' '''
        if value_type == Uint64_t:
            # ss_values_len = min( [ss_v.size() for ss_v in shamir_shares.values()] )
            # Nnp = N*np if np else ss_values_len
            logq = self.ckks_params.logq
            np = np if np else ceil( (1+logq+logN+2) / pbnd )
            Nnp = N*np

            di_inxs = list(shamir_shares.keys())
            ss_shares = SKShares(threshold, np)
            for i in range(threshold):
                di_inx = di_inxs[i]
                ss_inx, ss_val = int(di_inx)+1, shamir_shares[di_inx]
                ss_shares.setShares(i, ss_inx, ss_val)
            
            if not reconstruct_flag and not mod:
                rres = Uint64_t(Nnp)
                scheme.recoverSecret(rres, ss_shares)
                return rres
            else:
                res = ZZ(N)
                if not mod: # default mod is q
                    mod = ZZ([ring.qpows[logq]])
                elif not isinstance(mod, ZZ): 
                    mod = ZZ([mod])
                # ring.multiplier.reconstruct(res, rres, np, mod)
                scheme.recoverSecret(res,logq, ss_shares)
                return res

            
        elif value_type == share:
            if mod:
                return interpolate(shamir_shares, threshold=threshold)%mod
            else:
                return interpolate(shamir_shares, threshold=threshold)
        else:
            raise ValueError("Inputting element of shares to __shareRecover__ must be a Uint64_t or share.")

    def shareRecover(self, shamir_shares, share_modulus=None, threshold=None, np=None, mod=None, reconstruct_flag=True, multi_flag=False):
        ''' '''
        assert isinstance(shamir_shares, dict)
        # threshold = threshold if threshold else self.threshold
        threshold = threshold if threshold else len(shamir_shares)
        modulus = share_modulus if share_modulus else pVec # decshare_sss is Uint64 mod pVec
        mod = mod if mod else int(ring.qpows[self.ckks_params.logq]) # decshare is ZZ(N) mod q
        np = np if np else ceil( (1+self.ckks_params.logq+logN+2) / pbnd )
        
        value_sample = list(shamir_shares.values())[0] 
        if isinstance(value_sample, list):
            values_len = len(value_sample)
            shamir_shares_list = [{}]*values_len
            for inx, share_values in shamir_shares.items():
                for i in range(values_len):
                    shamir_shares_list[i][inx] = share_values[i]
            if not multi_flag:
                return [ self.__shareRecover__(shamir_shares_list[0], modulus, threshold, type(value_sample[0]), reconstruct_flag=reconstruct_flag, np=np, mod=mod) ] * len(shamir_shares_list)
            else:
                shamir_shares_list = shamir_shares_list
                return [ self.__shareRecover__(shamir_shares_, modulus, threshold, type(value_sample[0]), reconstruct_flag=reconstruct_flag, np=np, mod=mod) for shamir_shares_ in shamir_shares_list ]
        
        elif isinstance(value_sample, Uint64_t) or isinstance(value_sample, share):
            return self.__shareRecover__(shamir_shares, modulus, threshold, type(value_sample), mod=mod)

        else:
            raise ValueError("Inputting element of shares to shareRecover must be a Uint64_t or share.")


    def partAggDecshareRecover(self, decsss_dict, multi_flag=False, share_modulus=None, threshold=None, np=None, mod=None):
        ''' '''
        assert isinstance(decsss_dict, dict)
        decsss_sample = list(decsss_dict.values())[0]
        #assert isinstance(decsss_sample, list)
        if not isinstance(decsss_sample, list):
            for inx, decsss in decsss_dict.items():
                decsss_dict[inx] = [decsss]
        decsss_sample = list(decsss_dict.values())[0]

        ciph_num = len(decsss_sample)
        decshare_list = []

        # multi_flag = False if len(set(decsss_sample[0]))==1 else True
        if multi_flag:
            ciph_inx_range = range(ciph_num)
            for ciph_inx in ciph_inx_range:
                decsss_dict_i = {}
                for inx, dec_sss_list in decsss_dict.items():
                    decsss_dict_i[inx] = dec_sss_list[ciph_inx]
                decshare_i = self.shareRecover(decsss_dict_i, share_modulus=share_modulus, threshold=threshold, reconstruct_flag=True, np=np, mod=mod)
                decshare_list.append(decshare_i)
        else:
            decsss_dict_i = {}
            for inx, dec_sss_list in decsss_dict.items():
                decsss_dict_i[inx] = dec_sss_list[0]
            decshare_i = self.shareRecover(decsss_dict_i, share_modulus=share_modulus, threshold=threshold, reconstruct_flag=True, np=np, mod=mod)
            decshare_list = [decshare_i]*ciph_num
        
        return decshare_list


    def partAggModelDecshareRecover(self, decsss_gm_dict, share_modulus=None, threshold=None, np=None, mod=None):
        ''' '''
        decshares_gm = []
        decsss_gm_example = list(decsss_gm_dict.values())[0]

        vs_ciph_num = len(decsss_gm_example)

        
        vs_decsss_dicts = [ {} for _ in range(v_ciph_num) ] 
        
        for inx, decsss_gm in decsss_gm_dict.items():
            for i in range(v_ciph_num):
                vs_decsss_dicts[i][inx] = decsss_gm[i]

        vs_ciph_inx_range = range(vs_ciph_num)
        for i in vs_ciph_inx_range:
            decshare_v = self.shareRecover(vs_decsss_dicts[i], share_modulus=share_modulus, threshold=threshold, reconstruct_flag=True, np=np, mod=mod)
            decshares_gm.append(decshare_v)

        return decshares_gm

    #### ------------------------------------------------------------
    #### ------------------------------------------------------------


    #### ------------------------------------------------------------
    #### ---------------- GET GLOBAL MODEL METHODS ------------------
    #### ------------------------------------------------------------ 
    #### ------------- BY ITERKEY (SINGLE SERVER CASE) --------------
    def getGlobalModelByIterkey(self, ciph_gm, model_len, iterkey=None, plain_flag=False):
        ''' '''
        # model_name = model_name if model_name else self.model_name
        gm = [] 
        dvecs = self.decryptByIterkey(ciph_gm, iterkey=iterkey, msg_flag=False)
        for dvec in dvecs:
            dvec_size = min( dvec.size(), model_len-len(gm) )
            gm += [ round(float(str(dvec[j].real()))) for j in range(dvec_size) ]
        return gm
    #### ------------------------------------------------------------
    #### ------------------------------------------------------------
    #### ------------------------------------------------------------


    #### ------------------------------------------------------------
    #### ----------------- EVALUATION MODEL METHODS -----------------
    #### ------------------------------------------------------------ 
    def setValInfo(self, di_index, mask, denominator):
        ''' Save the mask_r and denominatorfor di's local model evaluation '''
        if not hasattr(self, 'val'): 
            self.val = [None]*self.di_num
        self.val[di_index] = {'mask':mask, 'denominator':denominator}
    #### -- class EncModelEvaluateor in model_evaluator.py
    #### ------------------------------------------------------------ 
    #### ------------------------------------------------------------ 


    #### ------------------------------------------------------------
    #### ----------------- VERIFY SIGNATURE METHODS -----------------
    #### ------------------------------------------------------------ 
    def verSign(self, di_inx, msg, sign, weight=None):
        ''' verify one DI's signature using its lhs_pk '''
        pk = self.di_sign_public_keys[di_inx]
        verifier = MKLHSVerifier()
        ver_res = verifier.verifyLHSign(msg, sign, pk, weight=weight)
        return ver_res

    def verCiphsSign(self, di_inx, ciphs, sign, weight=None, return_msg_flag=False):
        ''' verify one DI's signature of ciphtxts using its lhs_pk '''
        pk = self.get_di_sign_public_key(di_inx)
        encoder = MKLHSEncoder()
        msg = encoder.ciphs2LHSMsgs(ciphs)
        verifier = MKLHSVerifier()
        ver_res = verifier.verifyLHSign(msg, sign, pk, weight=weight)
        if return_msg_flag:
            return ver_res, msg
        else:
            return ver_res

    def verCiphModelSign(self, di_inx, ciph_lm, sign):
        ''' verify one DI's signature of ciph_lm using its lhs_pk '''
        pk = self.get_di_sign_public_key(di_inx)
        lhsmsg_clm = modelCiph2LHSMsg(ciph_lm, self.ckks_params)
        verifier = MKLHSVerifier()
        ver_res = verifier.verifyLHSign(lhsmsg_clm, sign, pk)
        return ver_res

    def verSolnModelSign(self, di_inx, lhsmsg_soln, sign):
        ''' verify one DI's signature of lhsmsg_soln using its lhs_pk '''
        ver_res = self.verSign(di_inx, lhsmsg_soln, sign)
        return ver_res
    #### ------------------------------------------------------------ 
    #### ------------------------------------------------------------ 
    
    #### ------------------------------------------------------------ 
    #### --------------- EVALUATION SIGNATURE METHODS ---------------
    #### ------------------------------------------------------------ 
    def evalSigns(self, signs, weights=None, di_inxs=None, msgs=None):
        ''' evaluate LHSigns to generate a MKLHSigns'''
        signers_num = 0
        if isinstance(signs, list):
            signers_num = len(signs)
        elif isinstance(signs, MKLHSSigns):
            signers_num = signs.signers_num
        elif isinstance(signs, LHSSigns):
            signers_num = 1
            signs = [signs]

        msgs_nums = []
        mksigns = MKLHSSigns(signers_num)
        for i in range(signers_num):
            assert isinstance(signs[i], LHSSigns)
            msgs_nums.append(signs[i].size)
            mksigns.setSigns(signs[i], i)
        assert len(set(msgs_nums)) == 1
        msgs_num = msgs_nums[0]

        encoder = MKLHSEncoder()
        fs = encoder.trans2MKLHSLinearity(weights, signers_num, msgs_num)
        sign_res = LHSSigns()
        global mklhs_scheme
        if not mklhs_scheme:
            mklhs_scheme = MKLHS_init()
        mklhs_scheme.evalSigns(sign_res, mksigns, fs)

        if di_inxs and msgs:
            mkpks = MKLHSPKeys(signers_num)
            mkmsgs = MKLHSMsgs(signers_num, msgs_num)
            for i in range(signers_num):
                di_inx =  di_inxs[i]
                mkpks.setPKs(self.get_di_sign_public_key(di_inx), i)
                mkmsgs.setMsgs(msgs[i], i)
            ver_res = mklhs_scheme.verMKLHS(sign_res, mkmsgs, fs, mkpks)

        return sign_res
    #### ------------------------------------------------------------ 
    #### ------------------------------------------------------------ 




